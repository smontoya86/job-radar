"""Configuration file writer for Job Radar."""

import os
import shutil
from datetime import datetime
from pathlib import Path
from typing import Optional

import yaml


class ConfigWriter:
    """Writes profile.yaml and .env configuration files."""

    def __init__(self, project_root: Optional[Path] = None):
        """Initialize config writer.

        Args:
            project_root: Path to project root. Defaults to auto-detect.
        """
        if project_root is None:
            # Auto-detect project root (3 levels up from this file)
            project_root = Path(__file__).parent.parent.parent
        self.project_root = project_root
        self.config_dir = project_root / "config"
        self.profile_path = self.config_dir / "profile.yaml"
        self.env_path = project_root / ".env"

    def write_profile(self, profile_dict: dict, backup: bool = True) -> Path:
        """Write profile.yaml configuration.

        Args:
            profile_dict: Profile configuration dictionary
            backup: If True, backup existing file before overwriting

        Returns:
            Path to written file
        """
        # Ensure config directory exists
        self.config_dir.mkdir(parents=True, exist_ok=True)

        # Backup existing file if it exists
        if backup and self.profile_path.exists():
            self._backup_file(self.profile_path)

        # Clean up None values from profile dict
        cleaned_dict = self._clean_none_values(profile_dict)

        # Write YAML with custom formatting
        content = self._format_profile_yaml(cleaned_dict)

        with open(self.profile_path, "w") as f:
            f.write(content)

        return self.profile_path

    def write_env(self, env_dict: dict, backup: bool = True) -> Path:
        """Write or update .env file.

        Args:
            env_dict: Dictionary of environment variables
            backup: If True, backup existing file before overwriting

        Returns:
            Path to written file
        """
        # Backup existing file if it exists
        if backup and self.env_path.exists():
            self._backup_file(self.env_path)

        # Read existing .env if it exists
        existing = {}
        if self.env_path.exists():
            existing = self._read_env()

        # Merge with new values (new values take precedence)
        merged = {**existing, **env_dict}

        # Write .env file
        content = self._format_env(merged)

        with open(self.env_path, "w") as f:
            f.write(content)

        return self.env_path

    def _backup_file(self, path: Path) -> Path:
        """Create a backup of a file.

        Args:
            path: Path to file to backup

        Returns:
            Path to backup file
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = path.with_suffix(f".{timestamp}.bak")
        shutil.copy2(path, backup_path)
        return backup_path

    def _read_env(self) -> dict:
        """Read existing .env file.

        Returns:
            Dictionary of environment variables
        """
        env = {}
        with open(self.env_path, "r") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, _, value = line.partition("=")
                    env[key.strip()] = value.strip()
        return env

    def _clean_none_values(self, d: dict) -> dict:
        """Recursively remove None values from dict.

        Args:
            d: Dictionary to clean

        Returns:
            Cleaned dictionary
        """
        if not isinstance(d, dict):
            return d

        return {
            k: self._clean_none_values(v)
            for k, v in d.items()
            if v is not None
        }

    def _format_profile_yaml(self, profile_dict: dict) -> str:
        """Format profile dictionary as YAML with comments.

        Args:
            profile_dict: Profile configuration dictionary

        Returns:
            Formatted YAML string
        """
        lines = ["# Job Search Profile Configuration", "# Generated by Job Radar Setup Wizard", ""]

        # Profile section
        lines.append("profile:")
        profile = profile_dict.get("profile", {})
        lines.append(f'  name: "{profile.get("name", "")}"')
        lines.append(f'  experience_years: {profile.get("experience_years", 5)}')
        if profile.get("layoff_date"):
            lines.append(f'  layoff_date: "{profile.get("layoff_date")}"')
        lines.append(f'  remote_preference: {str(profile.get("remote_preference", True)).lower()}')
        lines.append("")

        # Target titles
        lines.append("target_titles:")
        titles = profile_dict.get("target_titles", {})
        lines.append("  primary:")
        for title in titles.get("primary", []):
            lines.append(f'    - "{title}"')
        if titles.get("secondary"):
            lines.append("  secondary:")
            for title in titles.get("secondary", []):
                lines.append(f'    - "{title}"')
        lines.append("")

        # Required keywords
        lines.append("required_keywords:")
        keywords = profile_dict.get("required_keywords", {})
        lines.append("  # Must have at least one from primary")
        lines.append("  primary:")
        for kw in keywords.get("primary", []):
            lines.append(f'    - "{kw}"')
        if keywords.get("secondary"):
            lines.append("  # Bonus points for secondary")
            lines.append("  secondary:")
            for kw in keywords.get("secondary", []):
                lines.append(f'    - "{kw}"')
        lines.append("")

        # Negative keywords
        negative = profile_dict.get("negative_keywords", [])
        if negative:
            lines.append("negative_keywords:")
            lines.append("  # Exclude jobs containing these")
            for kw in negative:
                lines.append(f'  - "{kw}"')
            lines.append("")

        # Compensation
        lines.append("compensation:")
        comp = profile_dict.get("compensation", {})
        lines.append(f'  min_salary: {comp.get("min_salary", 100000)}')
        lines.append(f'  max_salary: {comp.get("max_salary", 200000)}')
        lines.append(f'  flexible: {str(comp.get("flexible", True)).lower()}')
        lines.append(f'  currency: "{comp.get("currency", "USD")}"')
        lines.append("")

        # Location
        lines.append("location:")
        loc = profile_dict.get("location", {})
        lines.append(f'  remote_only: {str(loc.get("remote_only", False)).lower()}')
        lines.append("  preferred:")
        for place in loc.get("preferred", ["Remote"]):
            lines.append(f'    - "{place}"')
        if loc.get("excluded"):
            lines.append("  excluded:")
            for place in loc.get("excluded", []):
                lines.append(f'    - "{place}"')
        lines.append("")

        # Target companies
        companies = profile_dict.get("target_companies", {})
        if any([companies.get("tier1"), companies.get("tier2"), companies.get("tier3")]):
            lines.append("target_companies:")
            if companies.get("tier1"):
                lines.append("  # Tier 1: Dream companies")
                lines.append("  tier1:")
                for c in companies.get("tier1", []):
                    lines.append(f'    - "{c}"')
            if companies.get("tier2"):
                lines.append("  # Tier 2: Great companies")
                lines.append("  tier2:")
                for c in companies.get("tier2", []):
                    lines.append(f'    - "{c}"')
            if companies.get("tier3"):
                lines.append("  # Tier 3: Good companies")
                lines.append("  tier3:")
                for c in companies.get("tier3", []):
                    lines.append(f'    - "{c}"')
            lines.append("")

        # Sources
        lines.append("sources:")
        sources = profile_dict.get("sources", {})
        lines.append("  enabled:")
        for s in sources.get("enabled", []):
            lines.append(f'    - "{s}"')
        if sources.get("disabled"):
            lines.append("  disabled:")
            for s in sources.get("disabled", []):
                lines.append(f'    - "{s}"')
        lines.append("")

        # Scoring
        lines.append("scoring:")
        scoring = profile_dict.get("scoring", {})
        lines.append(f'  title_match: {scoring.get("title_match", 0.20)}')
        lines.append(f'  keyword_match: {scoring.get("keyword_match", 0.40)}')
        lines.append(f'  company_tier: {scoring.get("company_tier", 0.15)}')
        lines.append(f'  salary_match: {scoring.get("salary_match", 0.05)}')
        lines.append(f'  remote_match: {scoring.get("remote_match", 0.05)}')
        lines.append(f'  min_notification_score: {scoring.get("min_notification_score", 50)}')
        lines.append(f'  min_save_score: {scoring.get("min_save_score", 30)}')
        lines.append("")

        # Notifications
        lines.append("notifications:")
        notif = profile_dict.get("notifications", {})
        slack = notif.get("slack", {})
        lines.append("  slack:")
        lines.append(f'    enabled: {str(slack.get("enabled", True)).lower()}')
        lines.append(f'    min_score: {slack.get("min_score", 50)}')
        lines.append(f'    include_low_score: {str(slack.get("include_low_score", False)).lower()}')
        lines.append(f'    batch_mode: {str(slack.get("batch_mode", False)).lower()}')
        lines.append(f'    batch_interval_hours: {slack.get("batch_interval_hours", 4)}')

        email = notif.get("email_digest", {})
        lines.append("  email_digest:")
        lines.append(f'    enabled: {str(email.get("enabled", False)).lower()}')
        lines.append(f'    frequency: "{email.get("frequency", "daily")}"')
        lines.append(f'    send_time: "{email.get("send_time", "09:00")}"')
        lines.append("")

        return "\n".join(lines)

    def _format_env(self, env_dict: dict) -> str:
        """Format environment dictionary as .env file.

        Args:
            env_dict: Environment variables dictionary

        Returns:
            Formatted .env content
        """
        lines = [
            "# Job Radar Environment Configuration",
            "# Generated by Job Radar Setup Wizard",
            "",
            "# Slack",
        ]

        slack_url = env_dict.get("SLACK_WEBHOOK_URL", "")
        lines.append(f"SLACK_WEBHOOK_URL={slack_url}")
        lines.append("")

        lines.append("# Gmail")
        lines.append(f"GMAIL_CREDENTIALS_FILE={env_dict.get('GMAIL_CREDENTIALS_FILE', 'credentials.json')}")
        lines.append(f"GMAIL_TOKEN_FILE={env_dict.get('GMAIL_TOKEN_FILE', 'token.json')}")
        lines.append("")

        lines.append("# Adzuna (optional)")
        lines.append(f"ADZUNA_APP_ID={env_dict.get('ADZUNA_APP_ID', 'your_id')}")
        lines.append(f"ADZUNA_APP_KEY={env_dict.get('ADZUNA_APP_KEY', 'your_key')}")
        lines.append("")

        lines.append("# Database")
        lines.append(f"DATABASE_URL={env_dict.get('DATABASE_URL', 'sqlite:///data/job_radar.db')}")
        lines.append("")

        lines.append("# Dashboard")
        lines.append(f"DASHBOARD_PORT={env_dict.get('DASHBOARD_PORT', '8501')}")
        lines.append("")

        lines.append("# Scheduler")
        lines.append(f"JOB_CHECK_INTERVAL_MINUTES={env_dict.get('JOB_CHECK_INTERVAL_MINUTES', '30')}")
        lines.append(f"EMAIL_CHECK_INTERVAL_MINUTES={env_dict.get('EMAIL_CHECK_INTERVAL_MINUTES', '15')}")
        lines.append("")

        return "\n".join(lines)
